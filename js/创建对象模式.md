# js面向对象的程序设计 #
-------
## 属性类型 <br>


- 数据类型
-
	1. Configurable 可删除性从而重新定义属性 默认 **true**
	2. Enumerable 可遍历 for-in 循环 默认 **true**
	3. Writable 可修改属性的值 默认 **true**
	4. Value 属性可读 默认 **undefined**
### test 1 ###

		var  person = {
 			name : "jay",
 			age : 23,
 			job : "Software Engineer",

 			sayName : function() {
 				console.log(this.name+ " " + this.age+" "+ this.job);
 			}
 		};
		// 属性所在的对象， 属性的名字（加上引号），描述的对象
		Object.definProperty(person, "name", {
			configurabel : false,
			Enumerable : false,
			Writable : false,
			value : "zhan"
		});
		console.log(person.name);   // zhan value属性更改了最初的值
		delete person.age;  		// false 
		for( var p in person) {
			if( p === "name") {
				alert(1);			// 不能完成 enumerable = false
			}
		}


- 访问器属性
-
	1. Configurabel 同上
	2. Enumerable   同上
	3. get 		在读取属性时调用的函数 默认 undefined
	4. set 		在写入属性时调用的函数 默认 undefined
<pre>
var book = {
	_year: 1993,   // 表示只能通过对象方法访问属性
	edition: 1
};
Object.defineProperty (book, "year", {
	get: function() {
		return this._year;
	},
	set: function(newValue) {
		if( newValue > 2004) {
			this._year = newValue;
			this.edition += newValue - 2004;
		}
	}
});
// Test 
book.year = 2005;		// 由于访问器属性包含getter和setter函数，把year改为2005会导致_year 为2004 
alert(book.edition);  	// 2
</pre>

# 创建对象

1. 构造函数模式
<pre>
	// 构造函数模式 
 		function Person(name, age, job) {
 			this.name = name;
 			this.age = age;
 			this.job = job;
 			this.sayName = function() {
 				alert(this.name);
 			};
 		}
 		var person3 = new Person("zh", 21, "Software Engineer");
 		var person4 = new Person("an", 22, "Doctor");
 		console.log( person3 instanceof Person && person4 instanceof Person); // true
</pre>
## 使用new来创建一个Person新实例，调用构造函数，一般会经历四个步骤
1. 创建一个新的对象
2. 将构造函数的作用域赋值给新对象
3. 执行构造函数里面的代码
4. 返回一个新对象
------
- **缺点**
- 构造函数模式功能创建的对象都是不同的作用域， 函数功能没有共享
<pre> alert(person3.sayName == person4.sayName);   // false </pre>  


 		

